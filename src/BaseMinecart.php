<?php

namespace pixelwhiz\minecart;

use pocketmine\block\Block;
use pocketmine\block\Carpet;
use pocketmine\block\Flowable;
use pocketmine\block\Liquid;
use pocketmine\block\SnowLayer;
use pocketmine\block\VanillaBlocks;
use pocketmine\data\bedrock\EffectIdMap;
use pocketmine\entity\animation\Animation;
use pocketmine\entity\Effect;
use pocketmine\entity\effect\EffectInstance;
use pocketmine\entity\Entity;
use pocketmine\entity\EntitySizeInfo;
use pocketmine\entity\Living;
use pocketmine\entity\Location;
use pocketmine\entity\Minecart;
use pocketmine\entity\Vehicle;
use pocketmine\event\entity\EntityMotionEvent;
use pocketmine\event\Listener;
use pocketmine\math\AxisAlignedBB;
use pocketmine\network\mcpe\NetworkBroadcastUtils;
use pocketmine\network\mcpe\protocol\AddActorPacket;
use pocketmine\network\mcpe\protocol\types\entity\EntityIds;
use pocketmine\network\mcpe\protocol\types\entity\EntityLink;
use pocketmine\network\protocol\AddEntityPacket;
use pocketmine\network\protocol\MovePlayerPacket;
use pocketmine\Server;
use pocketmine\world\Position;
use pocketmine\world\sound\Sound;
use pocketmine\math\Vector3;
use pocketmine\player\Player;


class BaseMinecart extends Living {

    private int $jumpTick = 30;

    /**
     * @return mixed
     */
    public function getMotionY()
    {
        return 1;
    }

    public function walk(float $motionX, float $motionZ, Player $rider): void {
        $this->location->yaw = $rider->getLocation()->getYaw();
        $this->location->pitch = $rider->getLocation()->getPitch();
        $direction_plane = $this->getDirectionPlane();
        $x = $direction_plane->x / 2.5;
        $z = $direction_plane->y / 2.5;

        switch ($motionZ) {
            case 1:
                $finalMotionX = $x;
                $finalMotionZ = $z;
                break;
            case -1:
                $finalMotionX = -$x;
                $finalMotionZ = -$z;
                break;
            default:
                $average = $x + $z / 2;
                $finalMotionX = $average / 1.414 * $motionZ;
                $finalMotionZ = $average / 1.414 * $motionX;
                break;
        }


        switch ($motionX) {
            case 1:
                $finalMotionX = $z;
                $finalMotionZ = -$x;
                break;
            case -1:
                $finalMotionX = -$z;
                $finalMotionZ = $x;
                break;
        }

        if ($this->shouldJump()) {
            $this->jumpVelocity = 0.5;
            $this->location->y = $this->location->y + 1;
        }

        $this->move($finalMotionX, $this->motion->y, $finalMotionZ);
        $this->updateMovement();
    }


    public function broadcastLink(Player $player, int $type = EntityLink::TYPE_RIDER) {
        foreach ($this->getViewers() as $viewer) {
            if (!isset($viewer->getViewers()[$player->getId()])) {
                $player->spawnTo($viewer);
            }
            
            $pk = new SetActorLinkPacket();
            $pk->link = new EntityLink($this->getId(), $player->getId(), $type, true, true);
            NetworkBroadcastUtils::broadcastPackets([$viewer], [$pk]);
        }
    }

    public function shouldJump(): bool {
        if ($this->getBlockInFront()->getTypeId() !== VanillaBlocks::AIR()) {
            return true;
        }

        if ($this->getBlockInFront(0.5) instanceof Carpet) {
            return true;
        }

        if ($this->getBlockInFront() instanceof Flowable) {
            return false;
        }

        if ($this->getBlockInFront() instanceof Liquid) {
            return true;
        }

        return false;
    }

    protected function onDeath(): void
    {
        parent::onDeath(); // TODO: Change the autogenerated stub
    }

    public function getBlockInFront(float $y = 0): Block {
        $pos = $this->getPosition()->add($this->getDirectionVector()->getX() * $this->getScale(), $y, $this->getDirectionVector()->getZ() * $this->getScale())->round();
        return $this->getWorld()->getBlock($pos);
    }

    public function getDirectionVector(): Vector3
    {
        return $this->getMotion()->normalize();
    }

    public function getOffsetPosition(Vector3 $vector3): Vector3
    {
        return $this->getPosition()->add(0, 0.25, 0);
    }

    public function getName(): string
    {
        return "Minecart";
    }

    /**
     * @return null
     */
    public function getVehicle()
    {
        return $this->vehicle;
    }


    public function getScale(): float
    {
        return 1.0;
    }

    public function getInitialDragMultiplier(): float {
        return 0;
    }

    protected function getInitialSizeInfo(): EntitySizeInfo
    {
        return new EntitySizeInfo(0.7, 0.98, 0.0);
    }

    protected function getInitialGravity(): float
    {
        return 0.1;
    }

    public static function getNetworkTypeId(): string
    {
        return "minecraft:minecart";
    }

}